import 'dart:async';
import 'package:drumly/blocs/bluetooth/bluetooth_bloc.dart';
import 'package:drumly/models/notes_model.dart';
import 'package:drumly/provider/app_provider.dart';
import 'package:drumly/screens/player/player_shared.dart';
import 'package:drumly/screens/songs/songs_model.dart';
import 'package:drumly/services/local_service.dart';
import 'package:drumly/shared/common_functions.dart';
import 'package:drumly/shared/countdown.dart';
import 'package:drumly/shared/send_data.dart';
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:provider/provider.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';

class SongVisualizer extends StatefulWidget {
  const SongVisualizer({required this.song, super.key});
  final SongModel song;

  @override
  State<SongVisualizer> createState() => _SongVisualizerState();
}

class _SongVisualizerState extends State<SongVisualizer>
    with SingleTickerProviderStateMixin {
  late AppProvider appProvider;
  YoutubePlayerController? _youtubeController;

  int _elapsedMs = 0;
  bool isPlaying = false;
  bool isPaused = false;
  bool hasStarted = false; // UI deƒüi≈üikliƒüi i√ßin
  double playerSpeed = 1.0;
  static const int baseLedDuration = 100;
  static const int preDropMs = 5000; // Damla 5 saniye √∂nce d√º≈ümeye ba≈ülar

  List<Color> _colors = [];
  final Map<int, HitGlow> activeHits = {};
  final Set<int> sentNoteIndices = {};

  bool showSpeedText = false;
  Timer? _speedTextTimer;
  Timer? _timer;

  @override
  void initState() {
    super.initState();
    appProvider = Provider.of<AppProvider>(context, listen: false);
    _loadDrumColors();

    // üéµ YouTube player ba≈ülat (ama otomatik ba≈ülatma)
    if (widget.song.fileUrl != null && widget.song.fileUrl!.isNotEmpty) {
      final videoId = YoutubePlayer.convertUrlToId(widget.song.fileUrl!);
      if (videoId != null) {
        _youtubeController = YoutubePlayerController(
          initialVideoId: videoId,
          flags: const YoutubePlayerFlags(
            autoPlay: false,
            hideControls: true,
            disableDragSeek: true,
          ),
        );
      }
    }

    // üêõ Debug: Nota bilgilerini yazdƒ±r
    print('üéµ Song: ${widget.song.title}');
    print('üìù Total notes: ${widget.song.notes?.length ?? 0}');
    if (widget.song.notes != null && widget.song.notes!.isNotEmpty) {
      final firstNote = widget.song.notes!.first;
      print(
        'üìç First note: i=${firstNote.i}, sM=${firstNote.sM}, led=${firstNote.led}',
      );
      if (widget.song.notes!.length > 1) {
        final secondNote = widget.song.notes![1];
        print(
          'üìç Second note: i=${secondNote.i}, sM=${secondNote.sM}, led=${secondNote.led}',
        );
      }
    }

    // Timer'ƒ± ba≈ülatma, sadece play'e basƒ±ldƒ±ƒüƒ±nda ba≈ülatacaƒüƒ±z
  }

  Future<void> _loadDrumColors() async {
    final List<Color> loaded = [];
    for (int i = 1; i <= 9; i++) {
      final drum = await StorageService.getDrumPart(i.toString());
      if (drum?.rgb != null && drum!.rgb!.length >= 3) {
        loaded.add(Color.fromRGBO(drum.rgb![0], drum.rgb![1], drum.rgb![2], 1));
      } else {
        loaded.add(_defaultColor(i));
      }
    }
    if (mounted) setState(() => _colors = loaded);
  }

  Color _defaultColor(int i) {
    const defaults = [
      Color.fromRGBO(220, 0, 0, 1),
      Color.fromRGBO(208, 151, 154, 1),
      Color.fromRGBO(255, 125, 0, 1),
      Color.fromRGBO(7, 219, 2, 1),
      Color.fromRGBO(0, 212, 154, 1),
      Color.fromRGBO(21, 25, 207, 1),
      Color.fromRGBO(235, 0, 255, 1),
      Color.fromRGBO(242, 255, 0, 1),
      Colors.white,
    ];
    return defaults[(i - 1).clamp(0, defaults.length - 1)];
  }

  /// üéµ Play / Pause davranƒ±≈üƒ±
  Future<void> _togglePlay(BluetoothBloc bloc) async {
    if (isPlaying) {
      // Pause moduna ge√ß
      setState(() {
        isPlaying = false;
        isPaused = true;
      });
      _timer?.cancel();
      _youtubeController?.pause();
      await SendData().sendHexData(bloc, [0]); // LED'leri kapat
      return;
    }

    // ƒ∞lk ba≈ülatma: UI'yi deƒüi≈ütir, sonra countdown g√∂ster
    if (!hasStarted) {
      // UI'yi hemen deƒüi≈ütir (drum resmi gelsin)
      setState(() {
        hasStarted = true;
        _elapsedMs =
            -5000; // 5 saniye √∂nceden ba≈ülat (countdown sƒ±rasƒ±nda damlalar d√º≈üs√ºn)
      });

      // Timer'ƒ± countdown SIRASINDA ba≈ülat (damlalar d√º≈ümeye ba≈ülasƒ±n)
      _timer?.cancel();
      _timer = Timer.periodic(const Duration(milliseconds: 16), (timer) {
        if (!mounted) return;

        setState(() {
          _elapsedMs += (16 * playerSpeed).round();
        });

        // Countdown bitene kadar bekle, YouTube'u ba≈ülatma
        if (_elapsedMs >= 0 && !isPlaying) {
          // Countdown bitti, artƒ±k √ßalmaya hazƒ±r
          return;
        }
      });

      // Yeni UI'da countdown g√∂ster (5 saniye)
      await showDialog(
        context: context,
        barrierDismissible: false,
        builder: (_) => const Countdown(),
      );

      // Countdown bitti, zamanlayƒ±cƒ±yƒ± 0'a ayarla
      setState(() {
        _elapsedMs = 0;
      });
    }

    // Devam et
    setState(() {
      isPlaying = true;
      isPaused = false;
    });

    // YouTube player'ƒ± ba≈ülat
    _youtubeController?.play();

    // Timer'ƒ± yeniden ba≈ülat - YouTube player ile senkronize
    _timer?.cancel();
    _timer = Timer.periodic(const Duration(milliseconds: 16), (timer) {
      if (!isPlaying) return;

      // YouTube player'dan ger√ßek zamanƒ± al (daha doƒüru senkronizasyon)
      if (_youtubeController != null && _youtubeController!.value.isPlaying) {
        _elapsedMs = _youtubeController!.value.position.inMilliseconds;
      } else {
        // YouTube player yoksa manuel saya√ß
        _elapsedMs += (16 * playerSpeed).round();
      }

      setState(() {});
      _handleHitsAtCurrentTime(bloc);
    });
  }

  Future<void> _onSpeedChange(double delta, BluetoothBloc bloc) async {
    playerSpeed = (playerSpeed + delta).clamp(0.5, 1.5);
    final int ledDuration = (baseLedDuration / playerSpeed).round();
    await SendData().sendHexData(bloc, splitToBytes(ledDuration));
    _youtubeController?.setPlaybackRate(playerSpeed);

    setState(() => showSpeedText = true);
    _speedTextTimer?.cancel();
    _speedTextTimer = Timer(const Duration(seconds: 2), () {
      if (mounted) setState(() => showSpeedText = false);
    });
  }

  Future<void> _handleHitsAtCurrentTime(BluetoothBloc bloc) async {
    final now = _elapsedMs;
    for (final note in widget.song.notes ?? <NoteModel>[]) {
      if (now >= note.sM && !sentNoteIndices.contains(note.i)) {
        final List<int> payload = [];
        for (final drumPart in note.led) {
          if (drumPart < 1 || drumPart > 9) continue;
          final drum = await StorageService.getDrumPart(drumPart.toString());
          if (drum?.led == null || drum?.rgb == null) continue;
          payload.addAll([drum!.led!, ...drum.rgb!]);
          final color = _colors[(drumPart - 1).clamp(0, _colors.length - 1)];
          activeHits[drumPart] = HitGlow(color: color, untilMs: now + 180);
        }
        if (payload.isNotEmpty) await SendData().sendHexData(bloc, payload);
        sentNoteIndices.add(note.i);
      }
    }
    activeHits.removeWhere((_, glow) => glow.untilMs <= now);
  }

  @override
  void dispose() {
    _timer?.cancel();
    _speedTextTimer?.cancel();
    _youtubeController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bluetoothBloc = context.read<BluetoothBloc>();
    final size = MediaQuery.of(context).size;
    final isDark = appProvider.isDarkMode;

    return Scaffold(
      backgroundColor: Colors.black,
      body: Stack(
        children: [
          // üéß G√∂r√ºnmeyen YouTube Player
          if (_youtubeController != null)
            SizedBox(
              width: 1,
              height: 1,
              child: YoutubePlayer(controller: _youtubeController!),
            ),

          // üé¨ ƒ∞lk ekran: Sadece animasyon
          if (!hasStarted)
            Center(
              child: Lottie.asset(
                'assets/animation/drummer.json',
                fit: BoxFit.fitWidth,
              ),
            ),

          // üé¨ ƒ∞lk ekran: Ortada b√ºy√ºk play butonu
          if (!hasStarted)
            Center(
              child: GestureDetector(
                onTap: () => _togglePlay(bluetoothBloc),
                child: Container(
                  width: size.width / 4,
                  height: size.width / 4,
                  decoration: BoxDecoration(
                    color:
                        (isDark ? Colors.white : Colors.black).withOpacity(0.3),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    Icons.play_arrow_rounded,
                    size: size.width / 8,
                    color:
                        (isDark ? Colors.white : Colors.black).withOpacity(0.7),
                  ),
                ),
              ),
            ),

          // ü•Å Oyun ekranƒ±: Drum g√∂rseli
          if (hasStarted)
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Image.asset(
                'assets/images/newDrum.png',
                fit: BoxFit.fitWidth,
              ),
            ),

          // üíß Oyun ekranƒ±: D√º≈üen damlalar
          if (hasStarted)
            CustomPaint(
              painter: SongFlowPainter(
                notes: widget.song.notes ?? [],
                elapsedMs: _elapsedMs,
                preDropMs: preDropMs,
                colors: _colors,
                screenSize: size,
                activeHits: activeHits,
              ),
              child: const SizedBox.expand(),
            ),

          // üèÉ Speed indicator
          if (showSpeedText && hasStarted)
            Positioned(
              bottom: size.height * 0.35,
              left: 0,
              right: 0,
              child: Center(
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                  decoration: BoxDecoration(
                    color: Colors.black87,
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Text(
                    'Speed: ${playerSpeed.toStringAsFixed(2)}x',
                    style: const TextStyle(color: Colors.white),
                  ),
                ),
              ),
            ),

          // üéÆ Oyun ekranƒ±: Control butonlarƒ±
          if (hasStarted)
            Positioned(
              bottom: size.height * 0.10,
              left: 0,
              right: 0,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  controlButton(
                    imagePath: 'assets/images/icons/turtle.png',
                    onPressed: () => _onSpeedChange(-0.25, bluetoothBloc),
                  ),
                  controlButton(
                    icon: isPlaying ? Icons.pause : Icons.play_arrow,
                    onPressed: () => _togglePlay(bluetoothBloc),
                    iconSize: 52,
                  ),
                  controlButton(
                    imagePath: 'assets/images/icons/rabbit.png',
                    onPressed: () => _onSpeedChange(0.25, bluetoothBloc),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}

class SongFlowPainter extends CustomPainter {
  SongFlowPainter({
    required this.notes,
    required this.elapsedMs,
    required this.preDropMs,
    required this.colors,
    required this.screenSize,
    required this.activeHits,
  });
  final List<NoteModel> notes;
  final int elapsedMs;
  final int preDropMs;
  final List<Color> colors;
  final Size screenSize;
  final Map<int, HitGlow> activeHits;

  Map<int, Offset> get targetPos => {
        1: _px(0.10, 0.78), // Hi-Hat - Sol
        2: _px(0.20, 0.73), // Crash - Sol
        3: _px(0.80, 0.70), // Ride - Saƒü
        4: _px(0.45, 0.85), // Snare - Orta
        5: _px(0.55, 0.68), // Tom 1 - Orta-Saƒü
        6: _px(0.65, 0.72), // Tom 2 - Saƒü
        7: _px(0.75, 0.80), // Floor Tom - Saƒü
        8: _px(0.50, 0.93), // Kick - Orta-Alt
        9: _px(0.90, 0.88), // Extra - En Saƒü
      };

  Offset _px(double rx, double ry) =>
      Offset(screenSize.width * rx, screenSize.height * ry);

  @override
  void paint(Canvas canvas, Size size) {
    final startY = size.height * 0.08; // Damlalarƒ±n ba≈ülangƒ±√ß Y pozisyonu (√ºst)
    final dropWidth = size.width * 0.05;
    const dropHeight = 56.0;

    // üíß Sadece aktif damlalarƒ± √ßiz (performans i√ßin)
    // Zaman aralƒ±ƒüƒ±nƒ± daralt: mevcut zamandan 5 saniye √∂nce ba≈ülayan ve hen√ºz √ßarpmamƒ±≈ü notalar
    final int timeWindowStart = elapsedMs - 500; // 500ms tolerans
    final int timeWindowEnd =
        elapsedMs + preDropMs; // ƒ∞leride g√∂r√ºnecek notalar

    for (final note in notes) {
      final int dropStartMs = note.sM - preDropMs;
      final int dropEndMs = note.sM;

      // Performans optimizasyonu: zaman penceresi dƒ±≈üƒ±ndaki notalarƒ± atla
      if (note.sM < timeWindowStart || note.sM > timeWindowEnd) continue;

      // Hen√ºz d√º≈üme zamanƒ± gelmedi veya √ßoktan √ßarptƒ± mƒ±?
      if (elapsedMs < dropStartMs || elapsedMs > dropEndMs) continue;

      // üé® ƒ∞lerleme hesaplama: 0.0 (ba≈ülangƒ±√ß/√ºst) ‚Üí 1.0 (hedef/drum)
      // Negatif zamanlarƒ± da handle ediyoruz
      final double progress =
          ((elapsedMs - dropStartMs) / preDropMs).clamp(0.0, 1.0);

      // üéµ Bu notanƒ±n LED listesindeki HER ELEMAN i√ßin ayrƒ± damla √ßiz
      // √ñrnek: note.led = [4, 8] ‚Üí 2 damla √ßizilecek (ye≈üil ve sarƒ±)
      for (final led in note.led) {
        // LED numarasƒ±nƒ± kontrol et (1-9 arasƒ± olmalƒ±)
        if (led < 1 || led > 9) continue;

        // LED numarasƒ±na g√∂re hedef pozisyonu al
        final pos = targetPos[led];
        if (pos == null) continue;

        // üé® LED numarasƒ±na g√∂re renk al
        // led = 1 ‚Üí colors[0], led = 2 ‚Üí colors[1], ... led = 9 ‚Üí colors[8]
        final colorIndex = (led - 1).clamp(0, colors.length - 1);
        final color = colors.isNotEmpty && colorIndex < colors.length
            ? colors[colorIndex]
            : Colors.white; // Fallback renk

        // üìç Damlanƒ±n ≈üu anki pozisyonunu hesapla
        final double x = pos.dx; // X sabit (yatay hareket yok)
        final double y = startY + progress * (pos.dy - startY); // Y √ºstten alta

        // üé® Damla ≈üeklini √ßiz (yuvarlatƒ±lmƒ±≈ü dikd√∂rtgen)
        final rect = Rect.fromLTWH(
          x - dropWidth / 2,
          y - dropHeight / 2,
          dropWidth,
          dropHeight,
        );
        final paint = Paint()
          ..shader = LinearGradient(
            colors: [
              color.withOpacity(0.0), // √úst kƒ±sƒ±m ≈üeffaf
              color.withOpacity(0.95), // Alt kƒ±sƒ±m opak
            ],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ).createShader(rect);
        canvas.drawRRect(
          RRect.fromRectAndRadius(rect, const Radius.circular(8)),
          paint,
        );
      }
    }

    // üéá HitGlow (vurma efekti) - drum'a √ßarpma anƒ±nda parlama
    for (final entry in activeHits.entries) {
      final pos = targetPos[entry.key];
      if (pos == null) continue;
      final glow = entry.value;

      // ƒ∞ki katmanlƒ± parlama efekti
      for (int i = 0; i < 2; i++) {
        final radius = (i == 0) ? 36.0 : 68.0;
        final alpha = (i == 0) ? 0.35 : 0.18;
        final p = Paint()
          ..color = glow.color.withOpacity(alpha)
          ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 12);
        canvas.drawCircle(pos, radius, p);
      }

      // Merkez parlak nokta
      final centerPaint = Paint()..color = glow.color.withOpacity(0.9);
      canvas.drawCircle(pos, 16, centerPaint);
    }
  }

  @override
  bool shouldRepaint(covariant SongFlowPainter oldDelegate) =>
      oldDelegate.elapsedMs != elapsedMs ||
      oldDelegate.activeHits.length != activeHits.length;
}

class HitGlow {
  HitGlow({required this.color, required this.untilMs});
  final Color color;
  final int untilMs;
}
